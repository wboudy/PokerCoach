"""Tests for exploitation engine and recommendations."""

import pytest

from pokercoach.core.game_state import ActionType, GameState, Hand, Position
from pokercoach.opponent.exploiter import (
    Adjustment,
    AdjustedStrategy,
    ExploitationEngine,
)
from pokercoach.opponent.profiler import PlayerProfile, PlayerType
from pokercoach.opponent.stats import PlayerStats
from pokercoach.solver.bridge import Strategy


def make_strategy(
    fold: float = 0.0,
    call: float = 0.0,
    raise_: float = 0.0,
    bet: float = 0.0,
    check: float = 0.0,
) -> Strategy:
    """Helper to create a strategy."""
    actions = {}
    if fold > 0:
        actions[ActionType.FOLD] = fold
    if call > 0:
        actions[ActionType.CALL] = call
    if raise_ > 0:
        actions[ActionType.RAISE] = raise_
    if bet > 0:
        actions[ActionType.BET] = bet
    if check > 0:
        actions[ActionType.CHECK] = check
    return Strategy(hand=Hand.from_string("AsKs"), actions=actions)


def make_profile(
    player_type: PlayerType,
    hands: int = 100,
    vpip: float = 25.0,
    pfr: float = 20.0,
    fold_to_3bet: float = 60.0,
    fold_to_cbet: float = 50.0,
    af: float = 2.0,
) -> PlayerProfile:
    """Helper to create a player profile."""
    stats = PlayerStats(
        hands_played=hands,
        vpip=vpip,
        pfr=pfr,
        fold_to_3bet=fold_to_3bet,
        fold_to_cbet_flop=fold_to_cbet,
        aggression_factor=af,
    )
    return PlayerProfile(
        player_id="test_player",
        stats=stats,
        player_type=player_type,
        confidence=stats.confidence,
    )


@pytest.fixture
def engine() -> ExploitationEngine:
    """Create exploitation engine."""
    return ExploitationEngine()


@pytest.fixture
def game_state() -> GameState:
    """Create sample game state."""
    return GameState(pot=10.0, effective_stack=100.0, hero_position=Position.BTN)


class TestExploitRecommendations:
    """Tests for exploit recommendation generation."""

    def test_recommendations_vs_nit_high_fold_to_3bet(
        self, engine: ExploitationEngine, game_state: GameState
    ):
        """Test that we 3-bet more vs nits who fold to 3-bet."""
        gto_strategy = make_strategy(fold=0.3, call=0.3, raise_=0.4)
        profile = make_profile(
            PlayerType.NIT,
            fold_to_3bet=75.0,  # Folds 75% to 3-bets
            hands=100,
        )

        adjusted = engine.get_adjustment(game_state, gto_strategy, profile)

        # Should recommend more raising
        raise_adjustment = None
        for adj in adjusted.adjustments:
            if adj.action == ActionType.RAISE:
                raise_adjustment = adj
                break

        assert raise_adjustment is not None
        assert raise_adjustment.adjusted_frequency > raise_adjustment.gto_frequency
        assert "fold" in raise_adjustment.reason.lower()

    def test_recommendations_vs_fish_calling_station(
        self, engine: ExploitationEngine, game_state: GameState
    ):
        """Test that we bluff less vs fish who don't fold."""
        gto_strategy = make_strategy(bet=0.6, check=0.4)
        profile = make_profile(
            PlayerType.FISH,
            fold_to_cbet=25.0,  # Only folds 25% to cbets
            hands=150,
        )

        adjusted = engine.get_adjustment(game_state, gto_strategy, profile)

        # Should recommend less betting (bluffing)
        bet_adjustment = None
        for adj in adjusted.adjustments:
            if adj.action == ActionType.BET:
                bet_adjustment = adj
                break

        assert bet_adjustment is not None
        assert bet_adjustment.adjusted_frequency < bet_adjustment.gto_frequency

    def test_recommendations_vs_lag_over_aggressive(
        self, engine: ExploitationEngine, game_state: GameState
    ):
        """Test that we call more vs LAGs who bluff too much."""
        gto_strategy = make_strategy(fold=0.3, call=0.4, raise_=0.3)
        profile = make_profile(
            PlayerType.LAG,
            af=4.5,  # High aggression factor
            hands=200,
        )

        adjusted = engine.get_adjustment(game_state, gto_strategy, profile)

        # Should recommend more calling
        call_adjustment = None
        for adj in adjusted.adjustments:
            if adj.action == ActionType.CALL:
                call_adjustment = adj
                break

        assert call_adjustment is not None
        assert call_adjustment.adjusted_frequency > call_adjustment.gto_frequency
        assert "aggression" in call_adjustment.reason.lower()

    def test_no_recommendations_for_tag(
        self, engine: ExploitationEngine, game_state: GameState
    ):
        """Test that TAGs get minimal or no adjustments (close to GTO)."""
        gto_strategy = make_strategy(fold=0.3, call=0.3, raise_=0.4)
        profile = make_profile(
            PlayerType.TAG,
            vpip=22.0,
            pfr=18.0,
            fold_to_3bet=55.0,
            fold_to_cbet=50.0,
            af=2.5,
            hands=100,
        )

        adjusted = engine.get_adjustment(game_state, gto_strategy, profile)

        # TAGs are balanced - should have few/no adjustments
        # (Currently returns empty list for TAGs)
        assert len(adjusted.adjustments) == 0

    def test_low_sample_size_reduces_confidence(
        self, engine: ExploitationEngine, game_state: GameState
    ):
        """Test that low sample size yields low confidence."""
        gto_strategy = make_strategy(fold=0.3, call=0.3, raise_=0.4)
        profile = make_profile(PlayerType.NIT, hands=25, fold_to_3bet=80.0)

        adjusted = engine.get_adjustment(game_state, gto_strategy, profile)

        for adj in adjusted.adjustments:
            assert adj.confidence == "low"

    def test_high_sample_size_yields_high_confidence(
        self, engine: ExploitationEngine, game_state: GameState
    ):
        """Test that high sample size yields high confidence."""
        gto_strategy = make_strategy(fold=0.3, call=0.3, raise_=0.4)
        profile = make_profile(PlayerType.NIT, hands=250, fold_to_3bet=80.0)

        adjusted = engine.get_adjustment(game_state, gto_strategy, profile)

        for adj in adjusted.adjustments:
            assert adj.confidence == "high"

    def test_unknown_player_type_no_adjustments(
        self, engine: ExploitationEngine, game_state: GameState
    ):
        """Test that unknown player types get no adjustments."""
        gto_strategy = make_strategy(fold=0.3, call=0.3, raise_=0.4)
        profile = make_profile(PlayerType.UNKNOWN, hands=10)

        adjusted = engine.get_adjustment(game_state, gto_strategy, profile)

        assert len(adjusted.adjustments) == 0


class TestAdjustedStrategy:
    """Tests for AdjustedStrategy class."""

    def test_final_strategy_sums_to_one(self):
        """Test that final strategy frequencies sum to 1."""
        base = make_strategy(fold=0.3, call=0.4, raise_=0.3)
        adjustments = [
            Adjustment(
                action=ActionType.RAISE,
                gto_frequency=0.3,
                adjusted_frequency=0.5,
                reason="Test",
                confidence="medium",
            )
        ]
        adjusted = AdjustedStrategy(base_strategy=base, adjustments=adjustments)

        final = adjusted.final_strategy
        total = sum(final.values())

        assert abs(total - 1.0) < 0.01

    def test_adjustment_applied_to_final(self):
        """Test that adjustments are reflected in final strategy."""
        base = make_strategy(fold=0.2, call=0.4, raise_=0.4)
        adjustments = [
            Adjustment(
                action=ActionType.RAISE,
                gto_frequency=0.4,
                adjusted_frequency=0.6,
                reason="Test",
                confidence="high",
            )
        ]
        adjusted = AdjustedStrategy(base_strategy=base, adjustments=adjustments)

        final = adjusted.final_strategy

        # Raise should be increased
        assert final[ActionType.RAISE] > base.frequency(ActionType.RAISE)


class TestConfidenceCalculation:
    """Tests for confidence calculation."""

    def test_confidence_none_below_threshold(self, engine: ExploitationEngine):
        """Test confidence is 'none' with very low sample."""
        assert engine.get_adjustment_confidence(15) == "none"

    def test_confidence_low_at_threshold(self, engine: ExploitationEngine):
        """Test confidence is 'low' at minimum threshold."""
        assert engine.get_adjustment_confidence(20) == "low"
        assert engine.get_adjustment_confidence(49) == "low"

    def test_confidence_medium_at_threshold(self, engine: ExploitationEngine):
        """Test confidence is 'medium' at threshold."""
        assert engine.get_adjustment_confidence(50) == "medium"
        assert engine.get_adjustment_confidence(199) == "medium"

    def test_confidence_high_at_threshold(self, engine: ExploitationEngine):
        """Test confidence is 'high' at threshold."""
        assert engine.get_adjustment_confidence(200) == "high"
        assert engine.get_adjustment_confidence(1000) == "high"


class TestDeviationDecision:
    """Tests for should_deviate decision logic."""

    def test_should_not_deviate_with_low_sample(self, engine: ExploitationEngine):
        """Test that we don't deviate with insufficient data."""
        result = engine.should_deviate(
            gto_ev=5.0,
            exploit_ev=10.0,  # Even with high EV gain
            sample_size=10,  # Low sample
        )
        assert result is False

    def test_should_deviate_with_high_ev_gain(self, engine: ExploitationEngine):
        """Test that we deviate with sufficient EV gain and sample."""
        result = engine.should_deviate(
            gto_ev=5.0,
            exploit_ev=6.0,  # 1 BB gain
            sample_size=200,  # High confidence
        )
        assert result is True

    def test_should_not_deviate_small_gain_low_sample(
        self, engine: ExploitationEngine
    ):
        """Test that small gains need high confidence."""
        result = engine.should_deviate(
            gto_ev=5.0,
            exploit_ev=5.2,  # Only 0.2 BB gain
            sample_size=30,  # Low confidence
        )
        assert result is False
