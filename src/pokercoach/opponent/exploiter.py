"""Exploitation engine for generating adjusted strategies."""

from dataclasses import dataclass
from typing import Optional

from pokercoach.core.game_state import ActionType, GameState
from pokercoach.opponent.profiler import PlayerProfile, PlayerType
from pokercoach.solver.bridge import Strategy


@dataclass
class Adjustment:
    """A recommended adjustment to GTO strategy."""

    action: ActionType
    gto_frequency: float
    adjusted_frequency: float
    reason: str
    confidence: str  # low, medium, high


@dataclass
class AdjustedStrategy:
    """Strategy with exploitative adjustments."""

    base_strategy: Strategy
    adjustments: list[Adjustment]

    @property
    def final_strategy(self) -> dict[ActionType, float]:
        """Get final adjusted frequencies."""
        result = dict(self.base_strategy.actions)

        for adj in self.adjustments:
            result[adj.action] = adj.adjusted_frequency

        # Normalize to sum to 1.0
        total = sum(result.values())
        if total > 0:
            result = {k: v / total for k, v in result.items()}

        return result


class ExploitationEngine:
    """
    Generate exploitative strategy adjustments.

    Takes GTO strategy and opponent profile to recommend
    profitable deviations.
    """

    # Minimum sample size for different confidence levels
    MIN_SAMPLES_LOW = 20
    MIN_SAMPLES_MEDIUM = 50
    MIN_SAMPLES_HIGH = 200

    def __init__(self):
        pass

    def get_adjustment_confidence(self, sample_size: int) -> str:
        """Determine confidence based on sample size."""
        if sample_size >= self.MIN_SAMPLES_HIGH:
            return "high"
        elif sample_size >= self.MIN_SAMPLES_MEDIUM:
            return "medium"
        elif sample_size >= self.MIN_SAMPLES_LOW:
            return "low"
        else:
            return "none"

    def should_deviate(
        self,
        gto_ev: float,
        exploit_ev: float,
        sample_size: int,
        risk_tolerance: float = 0.1,
    ) -> bool:
        """
        Determine if exploitation is profitable given uncertainty.

        Args:
            gto_ev: Expected value of GTO play
            exploit_ev: Expected value of exploitative play
            sample_size: Number of hands observed
            risk_tolerance: Acceptable EV loss if wrong (in BB)

        Returns:
            True if exploitation is recommended
        """
        confidence = self.get_adjustment_confidence(sample_size)

        if confidence == "none":
            return False

        ev_gain = exploit_ev - gto_ev

        # Require higher EV gain with lower confidence
        required_gain = {
            "low": 0.5,  # Need 0.5 BB gain to deviate
            "medium": 0.25,
            "high": 0.1,
        }

        return ev_gain >= required_gain.get(confidence, float("inf"))

    def get_adjustments_vs_nit(
        self,
        game_state: GameState,
        gto_strategy: Strategy,
        profile: PlayerProfile,
    ) -> list[Adjustment]:
        """
        Generate adjustments vs nitty opponents.

        Nits fold too much, so we:
        - Steal more from late position
        - Bluff more postflop
        - Fold to their raises (they have it)
        """
        adjustments = []
        confidence = self.get_adjustment_confidence(profile.stats.hands_played)

        if profile.stats.fold_to_3bet > 65:
            # 3-bet lighter for value
            current_raise = gto_strategy.frequency(ActionType.RAISE)
            adjustments.append(
                Adjustment(
                    action=ActionType.RAISE,
                    gto_frequency=current_raise,
                    adjusted_frequency=min(1.0, current_raise * 1.3),
                    reason=f"Opponent folds to 3-bet {profile.stats.fold_to_3bet:.0f}% of time",
                    confidence=confidence,
                )
            )

        return adjustments

    def get_adjustments_vs_fish(
        self,
        game_state: GameState,
        gto_strategy: Strategy,
        profile: PlayerProfile,
    ) -> list[Adjustment]:
        """
        Generate adjustments vs fishy opponents.

        Fish call too much, so we:
        - Value bet thinner
        - Bluff less
        - Size up value bets
        """
        adjustments = []
        confidence = self.get_adjustment_confidence(profile.stats.hands_played)

        # Reduce bluffing frequency
        current_bet = gto_strategy.frequency(ActionType.BET)
        if current_bet > 0 and profile.stats.fold_to_cbet_flop < 40:
            adjustments.append(
                Adjustment(
                    action=ActionType.BET,
                    gto_frequency=current_bet,
                    adjusted_frequency=current_bet * 0.7,  # Bluff less
                    reason=f"Opponent only folds to c-bet {profile.stats.fold_to_cbet_flop:.0f}%",
                    confidence=confidence,
                )
            )

        return adjustments

    def get_adjustments_vs_lag(
        self,
        game_state: GameState,
        gto_strategy: Strategy,
        profile: PlayerProfile,
    ) -> list[Adjustment]:
        """
        Generate adjustments vs LAG opponents.

        LAGs bluff too much, so we:
        - Trap more with strong hands
        - Call down lighter
        - 4-bet lighter for value
        """
        adjustments = []
        confidence = self.get_adjustment_confidence(profile.stats.hands_played)

        # Increase calling frequency vs aggression
        current_call = gto_strategy.frequency(ActionType.CALL)
        if current_call > 0 and profile.stats.aggression_factor > 3:
            adjustments.append(
                Adjustment(
                    action=ActionType.CALL,
                    gto_frequency=current_call,
                    adjusted_frequency=min(1.0, current_call * 1.2),
                    reason=f"Opponent AF of {profile.stats.aggression_factor:.1f} suggests over-aggression",
                    confidence=confidence,
                )
            )

        return adjustments

    def get_adjustment(
        self,
        game_state: GameState,
        gto_strategy: Strategy,
        opponent_profile: PlayerProfile,
    ) -> AdjustedStrategy:
        """
        Generate adjusted strategy based on opponent profile.

        Args:
            game_state: Current game state
            gto_strategy: GTO strategy from solver
            opponent_profile: Opponent's profile

        Returns:
            AdjustedStrategy with recommended deviations
        """
        adjustments: list[Adjustment] = []

        # Route to player-type specific adjustments
        if opponent_profile.player_type == PlayerType.NIT:
            adjustments = self.get_adjustments_vs_nit(
                game_state, gto_strategy, opponent_profile
            )
        elif opponent_profile.player_type == PlayerType.FISH:
            adjustments = self.get_adjustments_vs_fish(
                game_state, gto_strategy, opponent_profile
            )
        elif opponent_profile.player_type == PlayerType.LAG:
            adjustments = self.get_adjustments_vs_lag(
                game_state, gto_strategy, opponent_profile
            )

        return AdjustedStrategy(
            base_strategy=gto_strategy,
            adjustments=adjustments,
        )
